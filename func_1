


function xd0 = func_1(frame, fs, header_wave)
%====================================================
% FSK receiver – F0 branch (ĐÃ SỬA)
%====================================================

%% ===== PARAMETERS =====
Ns = 800;
f0 = 12000;  % Tần số cho bit 0
Lz = 30;

% Header bits
header_bits = [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0];
Lh = length(header_bits);

% BPF cho f0
[b,a] = butter(5, [11600 12400]/(fs/2), 'bandpass');
header_wave_filtered = filtfilt(b,a, header_wave);
frame_filt = filtfilt(b,a, frame);

%% ===== IQ DEMOD (F0) =====


% IQ cho frame
N = length(frame_filt);
n = 0:N-1;

%header_wave_filtered = [header_wave_filtered, zeros(1,N - length(header_wave_filtered))];

I = cos(2*pi*f0*n/fs);
Q = sin(2*pi*f0*n/fs);

% nhân header với bộ IQ_h
xI_header = header_wave_filtered .* I(1:Lh*Ns);
xQ_header = header_wave_filtered .* Q(1:Lh*Ns);
% nhân data với bộ IQ
xI = frame_filt .* I;
xQ = frame_filt .* Q;

% LPF
[c,d] = butter(5, 60/(fs/2), 'low');

xI_header = filtfilt(c,d,xI_header);
xQ_header = filtfilt(c,d,xQ_header);

xI = filtfilt(c,d,xI);
xQ = filtfilt(c,d,xQ);

x  = (xI_header.^2 + xQ_header.^2);
y0 = (xI.^2 + xQ.^2);




%% ===== SYMBOL SAMPLING =====
Ns2 = floor(Ns/2);
count_bit = 0;
while abs(length(y0) - count_bit*Ns) > 400
     count_bit = count_bit+1;
end
numBits = count_bit;
% lấy mẫu đại diện của header
y0_samples_header = zeros(1,Lh);
for k1 = 1:Lh
    y0_samples_header(k1) = x((k1-1)*Ns + Ns2);
end
%lấy mẫu đại diện của data
y0_samples = zeros(1, numBits);
for k2 = 1:numBits
    y0_samples(k2) = y0((k2-1)*Ns + Ns2);
end



%% ===== XÁC ĐỊNH CẤU TRÚC KHUNG =====
% Giả sử cấu trúc: HEADER + ZEROS + DATA + ZEROS
% header: Lh bits, zeros: Lz bits, data: Ld bits, zeros: Lz bits

% Tổng số bits ước tính
total_bits = numBits;

% Tính Ld từ công thức: total_bits = Lh + Lz + Ld + Lz


% Tách phần tử
hr0 = y0_samples(1:Lh+Lz);      % Header + zeros
yr0 = y0_samples(Lh+Lz+1:total_bits);  % Data + zeros
Ld = length(yr0) - Lz;



%% ===== FFT EQUALIZATION =====

% Đảm bảo cùng độ dài
if length(hr0) > length(yr0)
    l_max =  length(hr0);
    yr0_eq = [yr0,zeros(1,length(hr0)- length(yr0))];
    hr0_eq = hr0;
else
    l_max =  length(yr0);
    hr0_eq = [hr0,zeros(1,length(yr0)- length(hr0))];
    yr0_eq = yr0;
end


% Thêm zeros cho reference
x_added_zeros = [y0_samples_header, zeros(1, l_max - Lh)];

% FFT equalization
HP0 = fft(hr0_eq, l_max);      % header nhan
XP = fft(x_added_zeros, l_max);% header co san

eps0 = 0;
H0 = HP0 ./ (XP + eps0);
H0 = mean(H0);
disp('H0 : ');
disp(H0);

% Áp dụng cho data
YD0 = fft(yr0_eq, l_max);
XR0 = YD0 / (H0 + eps0);

xr0 = ifft(XR0);

%% ===== OUTPUT =====
xd0 = xr0(1:Ld);
%% Xoay pha
phi_sum = 0;
i = 1;
cnt = 0;

 while i <= length(xd0)
    if real(xd0(i)) > 0
        phi_sum = phi_sum + angle(xd0(i));
        cnt = cnt + 1;
    end
   i = i + 1;
end

if cnt == 0
    xd0 = xd0;
else
    phi_avg = phi_sum / cnt;
    xd0 = xd0 .* exp(1j*phi_avg);
end

%% ===== PLOT |xd0| (NĂNG LƯỢNG SYMBOL F1) =====
% figure;
% stem(1:length(xd0), real(xd0), 'filled');
% xlabel('Symbol index');
% ylabel('|xd0|');
% title('Biên độ (năng lượng) nhánh F0 sau IFFT');
% grid on;

end
